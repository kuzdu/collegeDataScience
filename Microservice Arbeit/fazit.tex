\section{Fazit}

Das Ziel, den Aufbau einer API basierend auf der Microservice Architektur anhand des Spieles Stirnraten, betrachte ich meiner Meinung nach als gelungen. Mittels Domain Driven Design konnten verschiedene Microservices detektiert und abgegrenzt werden. Unterstüzend diente User Story Mapping als Werkzeug zum Erfassen von Anforderungen. Diese wurden nach Priorität sortiert und gewährleisten die Einsatzfähigkeit des entstanden Produktes sowie mögliche Ausbauarbeiten. Selbstverständlich konnten nicht alle Anforderungen umgesetzt werden. \\

Zusätzlich wurde eine Microservice Architektur erschaffen, die den in den Grundlagen definierten Bewertungskriterien an die Microservices entspricht. Zusätzlich wurden empfohlene Pattern wie das Verwenden eines Gateways und das Nutzen der asynchronen Kommunikation angewandt. Ebenfalls bietet die Authentifizierung sowie Autorisierung ein hohes Maß an Flexiblität. Dies bedeutet, weitere Microservices aber auch etwaige Drittnutzer können einen kontrollierten Zugriff auf die API erhalten.\\

Trotz der erfolgreichen Umsetzung, gilt darauf hinzuweisen, dass der Umfang der Anforderungen an dieses Projekt derzeit keine Microservice Architektur rechtfertigen würde und deshalb eher prototypisch zu betrachten ist. Durch die vielen verschiedenen Microservices ist Mehrarbeit entstanden. Beispielsweise hätte die Datenstruktur mühelos auf eine Datenbank abgebildet werden können, stattdessen wurden drei Datenbanken verwendet. 

%SERVICE MESH oder SERVICEMESH
\subsection{Ausblick}
Diese Projektarbeit bietet ebenfalls noch zahlreiche, technische Erweiterungen an. Die Portvergabe und das Zusammenspiel der Microservices war aufwändig und teilweise sehr fehleranfällig, da es manuell und per Hand betrieben worden ist. Wenn die Serviceanzahl wächst, ist dies tendenziell eine große Fehlerquelle, da es ein hoher Arbeitsaufwand ist, nicht den Überblick zu verlieren. Dafür gibt es bereits mögliche Lösungen. Zum einen wäre Kubernetes als Orchestrierungsprogramm möglich. Zum anderen könnte ein sogenannter Service Mesh/Servicemesh erforscht werden, bei dem die Microservices sehr vereinfacht ausgedrückt, sich selbst ins System einpflegen. \\

Zusätzlich sollte eine automatisierte Build- und Deploymentstruktur (CI/CD) erschaffen werden. Open Source Tools wie z.B. Jenkins oder kostenpflichtige Tools wie z.B. Bamboo bieten zahlreiche Automatisierungsoptionen. Automatisierte Build- und Deploymentscripts sparen viel Zeit und Aufwände. \\

Wenn die Last wächst, sollten Microservices skalierbar sein. Das Verwenden von mehreren Servern und einem Loadbalancer, der die Last entsprechend verteilt, wären mögliche Lösungsansätze. Natürlich müssen dabei zusätzliche Aspekte beachtet werden, wie z.B. dass keine Inkonsistenzen in den Datenbanken entstehen. \\

%auschreiben (ELK Stack)
Der letzte und möglicherweise wichtigste Punkt ist die Microservices zu überwachen. Dies umfasst, entstandene Errors zu erkennen (Logging). Dafür gibt es bereits etablierte Tools wie z.B. den ELK Stack. Ebenfalls sollte man sich die Frage stellen, was passiert, wenn ein Service ausfällt oder ob er eine Route hat, wo man intern sehen kann, wie es ihm geht (Health Check). \\
 
Natürlich sind die genannten Ausblicke auch für eine monolithische Anwendung wichtig. Allerdings bewerte ich die Umsetzung der genannten Punkte in einer Microservice Architektur als komplexer und umfangreicher. Umso größer die Anwendung wird, desto eher sollte man eine Microservice Architektur verwenden.
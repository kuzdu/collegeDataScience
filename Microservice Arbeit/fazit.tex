\section{Fazit}

Das Ziel, den Aufbau einer API basierend auf der Microservice Architektur anhand des Spieles Stirnraten, betrachte ich meiner Meinung nach als gelungen und abgeschlossen. Mittels Domain Driven Design konnten verschiedene Microservices detektiert und abgegrenzt werden. Unterstüzend diente User Story Mapping als Werkzeug zum Erfassen von Anforderungen. Diese wurden nach Priorität sortiert und es ist ein Produkt entstanden, welches aktiv eingesetzt werden kann. Ebenfalls werden weitere Ausbaustufen aufgezeigt, da selbstverständlich nicht  alle erfassten Anforderungen aus Kapazitätsgründen umgesetzt wurden. \\

Weiter wurde eine Microservice Architektur erschaffen, die den definierten Bewertungskriterien für Microservices entspricht. Zusätzlich wurden empfohlene Pattern wie das Verwenden eines Gateways und das Nutzen der asynchronen Kommunikation angewandt. Die Authentifizierung sowie Autorisierung bietet ein hohes Maß an Flexiblität. Dies bedeutet, dass weitere Microservices, aber auch etwaige Drittnutzer, einen kontrollierten Zugriff auf die API erhalten könnten.\\

Trotz der erfolgreichen Umsetzung, gilt darauf hinzuweisen, dass der Umfang der Anforderungen an dieses Projekt derzeit keine Microservice Architektur rechtfertigen würde und deshalb eher prototypisch zu betrachten ist. Durch die vielen verschiedenen Microservices ist Mehrarbeit entstanden. Beispielsweise hätte die Datenstruktur mühelos auf eine Datenbank abgebildet werden können, stattdessen wurden drei Datenbanken verwendet. 

%SERVICE MESH oder SERVICEMESH
\subsection{Ausblick}
Diese Projektarbeit bietet noch zahlreiche, technische Erweiterungen an. Die Portvergabe und das Zusammenspiel der Microservices war aufwändig und teilweise sehr fehleranfällig, da es manuell und per Hand betrieben worden ist. Wenn die Serviceanzahl wächst, ist dies tendenziell eine große Fehlerquelle, da es ein hoher Arbeitsaufwand ist, nicht den Überblick zu verlieren. Dafür gibt es bereits mögliche Lösungen. Zum einen wäre Kubernetes als Orchestrierungsprogramm möglich. Zum anderen könnte ein sogenannter Service-Mesh erforscht werden, bei dem die Microservices sehr vereinfacht ausgedrückt, sich selbst ins System einpflegen. \\

Zusätzlich sollte eine automatisierte Build- und Deploymentstruktur (CI/CD) erschaffen werden. Open Source Tools wie z.B. Jenkins oder kostenpflichtige Tools wie z.B. Bamboo bieten zahlreiche Automatisierungsoptionen. Automatisierte Build- und Deploymentscripts sparen viel Zeit und Aufwand. \\

Wenn die Last wächst, sollten Microservices skalierbar sein. Das Verwenden von mehreren Servern und einem Loadbalancer, der die Last entsprechend verteilt, wären mögliche Lösungsansätze. Natürlich müssen dabei zusätzliche Aspekte beachtet werden, wie z.B. dass keine Inkonsistenzen in den Datenbanken entstehen. \\

Der letzte und möglicherweise wichtigste Punkt ist, die Microservices zu überwachen. Dies umfasst, entstandene Errors zu erkennen (Logging). Dafür gibt es bereits etablierte Tools wie z.B. den ELK Stack (Elasticsearch, Logstash, Kibana). Ebenfalls sollten Strategien überlegt werden, was passiert, wenn ein Service ausfällt und wie man diesen Zustand bereits frühzeitig bemerkt (Health Check). \\
 
Natürlich sind die genannten Ausblicke auch für eine monolithische Anwendung wichtig, allerdings bewerte ich die Umsetzung der genannten Punkte in einer Microservice Architektur als komplexer und umfangreicher. Umso größer die Anwendung wird, desto eher sollte man eine Microservice Architektur verwenden.
\pagebreak
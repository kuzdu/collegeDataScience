\section{Implementierung}
Das ist der Implementierungspart

\subsection{Authentifizierung und Autorisierung}
Ein zentraler Teil bei Microservices ist die Authentifizierung sowie die Autorisierung. Es wurde sich für eine Identity Server mit OAuth2 entschieden. Die MySQL-Datenstruktur ergibt sich aus dem Datenmodell:

\begin{verbatim}
public class User
{
    [Required] public int Id { set; get; }
    public string Name { set; get; }
    public string Password { set; get; }
    public bool Active { set; get; }
    public string Role { set; get; }
}
\end{verbatim}

Als eindeutiger Identifier ist eine `Id` notwendig. Zusätzlich besitzt jeder User einen Namen, ein Passwort, ist im Standaradfall aktiviert und es wird zwischen zwei Rollen unterschieden: `customer` und  `admin`. Wie zu erwarten hat die `admin`-Rolle mehr Berechtigung als ein Customer. \\

Um den Identity Server einzurichten, müssen sogenannte NuGet-Pakete heruntergeladen werden. NuGet ist ein System, mit welchem Softwarebibliotheken bereitgestellt werden können. Diese Verweise werden zur Projektdatei hinzugefügt.

\begin{verbatim}
<PackageReference Include="IdentityServer4" Version="2.3.0" />
<PackageReference Include="IdentityServer4.AccessTokenValidation" Version="2.7.0" />
\end{verbatim}

In der `Startup.cs`, welche standardmäßig bei C\# .net vorliegt, werden grundsätzlich Serverkonfigurationen initialisiert. Dies muss für den Identity Server ebenfalls getan werden.

\begin{verbatim}
(1)
var builder = services.AddIdentityServer()
.AddInMemoryIdentityResources(Config.GetIdentityResources()) //check below
.AddInMemoryApiResources(Config.GetApis())
.AddInMemoryClients(Config.GetClients())
.AddProfileService<ProfileService>();

services.AddTransient<IResourceOwnerPasswordValidator, ResourceOwnerPasswordValidator>();
services.AddTransient<IProfileService, ProfileService>();
	
	(2)
	services.AddAuthentication("Bearer")
	.AddJwtBearer("Bearer", options =>
{
   options.Authority = "http://identity_server_service";
   [...]
   options.Audience = "srapi";
});
\end{verbatim}  

Wie man feststellen kann, sind diese Konfigurationen schon recht umfangreich, obwohl es sich in dieser Version schon um eine sehr leichtgewichtige Implementierung von OAuth2 handelt. In (1) wird der Identity Server zum Projekt hinzugefügt. Zusätzlich wird auf den `ProfileService` sowie den `ResourceOwnerPasswordValidator` verwiesen, welche anschließend initialisiert werden müssen. In (2) wird noch die `Authority` und die `Audience` gesetzt. Die `Authority` garantiert zusätzlich, dass das Token nicht von einem anderen Identity Server ausgestellt wird. Die `Audience` gibt noch einmal an, dass das ausgestellte Token nur Zugriff auf eine entsprechende `srapi`(Stirnraten-API) Ressource hat. 

\begin{verbatim}
new ApiResource("srapi", "Stirnraten API")
{
    ApiSecrets = new List<Secret>()
    {
    new Secret(CustomClientSecret.Sha256())
    }
}
\end{verbatim}

Zusätzlich müssen noch die beiden in den Grundlagen erwähnten Flows (`ClientCredentials` und `ResourceOwnerPassword`) implementiert werden. 

\begin{verbatim}{
[...]
new Client
{
    ClientId = CustomClientId,
    AllowedGrantTypes = GrantTypes.ClientCredentials,
    ClientSecrets =
    {
    new Secret(CustomClientSecret.Sha256())
    },
    AllowedScopes =
    {
    "srapi"
    }
},

new Client
{
    ClientId = "sr.client",
    AllowedGrantTypes = GrantTypes.ResourceOwnerPassword,
    ClientSecrets =
    {
    new Secret("secret".Sha256())
    },
    AllowedScopes =
    {
    "srapi"
    }
}

\end{verbatim}

Durch diese Flows ist garantiert, dass die API grundsätzlich geschützt ist, d.h. auch dann wenn Benutzer keine Benutzerdaten hinterlegt haben. Werden allerdings benutzerspezifische Zugänge hinterlegt, erhalten diese noch mehr Zugriffsrechte auf die API. Dies wird im Bereich \ref{sec:umsetzung_api_gateway} deutlich. \\

Wenn eine Anfrage mit Benutzernamen und Passwort gestellt wird, ruft der Identity Server in seinem Abarbeitungszyklus folgende Methode ab: 

\begin{verbatim}
public async Task ValidateAsync(ResourceOwnerPasswordValidationContext context)
		{
		(1)
		var user = await _unitOfWork.UserRepository.GetUserByNameAndPasswordAsync(context.UserName,
		context.Password);
		
		(2)
		if (user == null)
		{
		context.Result = new GrantValidationResult(
		TokenRequestErrors.InvalidGrant,
		"invalid custom credential");
		return;
		}
		
		if (!user.Active)
		{
		context.Result = new GrantValidationResult(
		TokenRequestErrors.InvalidClient,
		"User was deactivated by admin");
		return;
		}
		
		(3)
		context.Result = new GrantValidationResult(
		subject: user.Id.ToString(),
		authenticationMethod: "custom",
		claims: GetUserClaims(user)); //get user claims
		}
\end{verbatim}

In (1) wird ein Benutzer gesucht, welcher mit dem übergebenen Namen und Passwort übereinstimmt. In (2) wird dieser validiert und in (3) das Token anhand der `Claims` generiert. `Claims` sind vereinfacht ausgedrückt, zusätzlich Informationen, welche man in dem Token übergeben möchte. 

\begin{verbatim}
return new[]
{
new Claim("user_id", user.Id.ToString() ?? ""),
new Claim(JwtClaimTypes.Name, user.Name),
new Claim(JwtClaimTypes.Role, user.Role)
};
\end{verbatim}

In der umgesetzten API wird eine `user\_id`, der `Name` sowie die `Role` übergeben. Alles wird ggf. von anderen Microservices benötigt, um eine entsprechende Autorisierung zu gewährleisten.\\

Abbildung \ref{fig:client_credentials_flow} und \ref{fig:password_flow} zeigen wie über eine POST Abfrage die entsprechenden Token ausgestellt werden können.\\

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.6\textwidth]{client_credentials_flow}
	\caption[Über Postman gesendeter Client Credential Flow] {Über Postman gesendeter Client Credential Flow. Mit Hilfe dieses Tokens erhält man für 3600 Sekunden (eine Stunde) beschränkten Zugang zur API, um  z.B. Kategorien abzurufen, neue Wörter einzusenden oder ein Benutzerkonto anzulegen.}
	\label{fig:client_credentials_flow}
\end{figure} 

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.6\textwidth]{password_flow}
	\caption[Über Postman gesendeter Password Flow] {Über Postman gesendeter Password Flow. Er ist ebenfalls 3600 Sekunden lang gültig und hat mehr Berechtigung, wie z.B. das Speichern eines Benutzerprofils.}
	\label{fig:password_flow}
\end{figure} \\

Enkodiert sieht so ein ausgestellter Benutzer-Token wie folgt aus: \\

\begin{verbatim}
		[...]
		"iss": "http://identity_server_service",
		"aud": [
		"http://identity_server_service/resources",
		"srapi"
		],
		"client_id": "sr.client",
		[...]
		"role": "admin",
		"user_id": "1",
		"scope": [
		"srapi"
		],
		"amr": [
		"custom"
		]
		[...]
\end{verbatim}  

Durch diese Informationen kann das API-Gateway bereits eine Autorisierung vornehmen. Wie dies im Detail funktioniert, wird im Abschnitt \ref{umsetzung_api_gateway} deutlich. 

\subsection{Umsetzung API-Gateway}\label{sec:umsetzung_api_gateway}

Ähnlich wie bei dem Identity Server müssen für Ocelot auch gewisse Bibliotheken über NuGet hinterlegt werden.

\begin{verbatim}
 <PackageReference Include="IdentityServer4.AccessTokenValidation" Version="3.0.0-preview.2" />
<PackageReference Include="IdentityServer4" Version="2.4.0" />
<PackageReference Include="Ocelot" Version="11.0.2" />
<PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" />
\end{verbatim}

Durch diese Pakete wird zum einen das Ocelot Gateway eingebunden, zum anderen wird der Authentifizierungsmechanismus zum Identity Server vereinfacht. Des Weiteren müssen Verbindungsdaten hinterlegt werden, die garantieren, dass das Gateway den Identity Server erreichen kann. Diese werden in der Startup.cs hinterlegt.

\begin{verbatim}
(1)
var authenticationProviderKey = "NTT9N7MXLJN9";

(2)
void Options(IdentityServerAuthenticationOptions o)
{
   o.Authority = "http://identity_server_service";
   o.ApiName = "srapi";
   o.RequireHttpsMetadata = false;
   o.SupportedTokens = SupportedTokens.Both;
   o.ApiSecret = "xxxxxx";
}
services.AddAuthentication()
.AddIdentityServerAuthentication(authenticationProviderKey, Options);

[...]
(3)
await app.UseOcelot();
[...]
\end{verbatim}

In (1) muss ein sogenannter `Authentication Provider Key` gesetzt werden. Dies ist obligatorisch vorgegeben von Ocelot und notwendig, um weitergeleitete Requests eindeutig zuzuordnen. In (2) werden die Optionen für die Verbindung zum Identity Server definiert. Diese Konfigurationen müssen mit den Einstellungen aus dem zuvor erwähnten Identity Server übereinstimmen. In (3) wird noch einmal explizit ausgedrückt, dass Ocelot auch verwendet werden soll. \\

Um eingehende Request zu verarbeiten, verwendet Ocelot eine JSON, in dem sogenannte ReRoutes (Weiterleitungen) hinterlegt werden. 

\begin{verbatim}
"ReRoutes": [
 {
 (1)
 "DownstreamPathTemplate": "/api/customers",
 (2)
 "DownstreamScheme": "http",
 "DownstreamHostAndPorts": [
    {
    (3)
    "Host": "customer_service",
    "Port": 80
    }
  ],
  (4)
  "UpstreamPathTemplate": "/api/stats",
  (5)
  "AuthenticationOptions": {
  "AuthenticationProviderKey": "NTT9N7MXLJN9",
  "AllowedScopes": [
    "srapi"
  ]
  },
  (6)
  "RouteClaimsRequirement": {
  "role": "admin"
  }
 },
[...]
]
\end{verbatim}

Diese dargestellte ReRoute zeigt bereits viele Vorteile von Ocelot. Durch (1) wird das `DownstreamPathTemplate` definiert. D.h. das Gateway präsentiert über das `UpstreamPathTemplate` (5) die öffentlichen Schnittstellen, welche man als Client anspricht. Dadurch lässt sich das Weiterleiten flexibel gestalten. Zusätzlich ist es nicht zwingend notwendig, dass wenn das `DownstreamPathTemplate` seine Route ändert, die Clienten davon betroffen sind, da das `UpstreamPathTemplate` gleichgeblieben ist. \\

Das `DownstreamScheme` (2) ist http, da die Microservices zu denen weiterleitet wird, nur in einem lokalen Netz befinden. Das hat den Vorteil, dass die Microservices nur über das Gateway zu erreichen sind. So kann garantiert werden, dass kein Dritter Zugriff auf die Services hat ohne über das Gateway zu gehen. \\

In (3) wird definiert an welchen Microservice weitergeleitet werden soll. In diesem Beispiel der `customer\_service`.\\

In (5) findet die Authentifizierung statt: Jeder Request welcher eingeht, muss im Token als Scope die `srapi` enthalten. In diesem Beispiel wird bereits auch autorisiert. Denn es wird die Rolle `admin` erwartet. D.h. wenn ein Request kein gültiges Token oder die entsprechende Rolle hat, wird der Request abgelehnt. \\

% noch ein Beispiel mit der Limitierung der Routen bringen

\subsection{Asynchrone  Kommunikation}
// ieine Queue umsetzen (RabbitMQ, Kafka...)

\subsection{Service Architektur}
% Morgen das
// nginx vom Hoster
// deployment
// Grafik erstellen, welche Services es gibt und wie diese Kommunizieren 
// Docker erwähnen und Beispiel einfügen




